---
title: 'Freya 0.3'
date: 2025-05-08
description: '0.3 release of Freya.'
author: 'marc2332'
layout: ../../layouts/BlogPostLayout.astro
slug: "0.3"
---
## Freya 0.3 Announcement

Hey again, this is the announcement for Freya v0.3.0, the latest release of my Rust GUI Framework.

![Website Example Screenshot](/blog/0.3/website.png)

This is https://freyaui.dev/ but made with Freya it self!

 Source code in [GitHub](https://github.com/marc2332/freya/blob/main/examples/website.rs)

### Incremental Rendering
Previously any change in the UI caused a full rerender. Now, rendering happens incrementally so only those all parts in the UI that change are rerendered, leaving the the rest intact, this translate to better performance even when consdering the cost of the calculations from incremental rendering.

For the purpose of internal debugging, I added a feature called `fade-cached-incremental-areas` to make the incremental rendering more evident. The parts of the UI that are left intact slowly fade out as new incremental renders are applied (this was inspired by an Iced video I saw some time ago). 

This is the [counter](https://github.com/marc2332/freya/blob/main/examples/counter.rs) example after me having moved my cursor a few times over the `Decrease` button.
![Incremental Rendering Counter Screenshot](/blog/0.3/incremental_rendering_counter.png)

### Layout

#### Flex
Freya now supports Flex layouting by using a combo of attributes, here is an example:

```rust
fn app() -> Element {
    rsx!(
        rect {
            content: "flex", // Marks this element as a Flex container
            direction: "horizontal",
            rect {
                width: "flex(1)", // Use 25% of the parent space after excluding the text from below
                height: "fill",
                background: "red"
            }
            label {
                "Some text here!"
            }
            rect {
                width: "flex(3)", // Use 75% of the parent space after excluding the text from above
                height: "fill",
                background: "green"
            }
        }
    )
}
```

![Flex Screenshot](/blog/0.3/flex.png)

#### Alignments
The new `space-between` / `space-around` / `space-evenly` mimic the behavior in CSS:


![Alignments List Screenshot](/blog/0.3/alignments_list.png)

#### Spacing attribute

The new `spacing` attribute is a small but nice addition, it allows you to specify the space between elements from their parent element:

```rust
fn app() -> Element {
    rsx!(
        rect {
            spacing: "10",
            for i in 0..6 {
                rect {
                    key: "{i}",
                    background: "rgb(25, 35, 45)",
                    width: "100%",
                    height: "50"
                }
            }
        }
    )
}
```


![Spacing Screenshot](/blog/0.3/spacing.png)

#### Global Position
Elements can now global positioned, meaning that they will be positioned starting at `X:0` and `Y:0` of the window and they will not affect any other sibling element.

So, like with `absolute` but where the relative point is the window and not the parent element.

Example:

```rust
fn app() -> Element {
    rsx!(
        rect {
            padding: "10",
            rect { // Notice how this uses the padding from the parent element
                height: "20%",
                width: "20%",
                background: "black",
                position: "absolute",
                position_top: "10",
                position_left: "10",
            }
            rect { // But this one doesn't
                height: "20%",
                width: "20%",
                background: "red",
                position: "global",
                position_top: "10",
                position_right: "10",
            }
        }
    )
}
```

![Position Screenshot](/blog/0.3/position.png)

Source code of the example in [GitHub](https://github.com/marc2332/freya/blob/main/examples/position.rs).



### Images

#### `aspect_ratio` and `cover`

Images before needed explicit sizing by the developer, this is now optional as images are by defauly sized according to their encoded size. You can still tweak this behavior with the new [`aspect_ratio`](https://docs.rs/freya/0.3.0-rc.4/freya/elements/image/constant.aspect_ratio.html) attribute.

In addition to that, a new [`cover`](https://docs.rs/freya/0.3.0-rc.4/freya/elements/image/constant.cover.html) attribute has been added to center the image according to its aspect ratio and size.

<video muted autoplay playsinline loop >
    <source src="/blog/0.3/aspect_ratio_cover.webm" type="video/webm" >
</video>

Source code of the example in [GitHub](https://github.com/marc2332/freya/blob/main/examples/images_slideshow.rs).

#### Cache Rendering

Images can now optionally cache their decoding at render-level by specifying a `cache_key`, this tells Freya to cache the image bytes and to not decode it again on the next frame.

```rust
static RUST_LOGO: &[u8] = include_bytes!("./rust_logo.png");

fn app() -> Element {
    rsx!(
        image {
            image_data: static_bytes(RUST_LOGO),
            width: "fill",
            height: "fill",
            aspect_ratio: "min",
            cache_key: "rust-logo",
        }
    )
}
```

This is used for example by `NetworkImage` with the `url` as a cache key.

Source code of an example in [GitHub](https://github.com/marc2332/freya/blob/main/examples/image_cache_key.rs).

### SVG
- import_svg

### Misc
- Reactive scale factor

- etc

### Virtualization
The `VirtualScrollview` now does pre-rendering of the closest items in both the start and the end, making the scroll way smoother.

<video muted autoplay playsinline loop >
    <source src="/blog/0.3/prerendering_virtual_scrollview.webm" type="video/webm" >
</video>

### Text Editing
Emojis support and other special characters are supported while editing text.

![Text Editing Screenshot](/blog/0.3/text_editing.png)

Other improvements like selecting with `Control + Shift + Arrows` have been added as well.

### Theming
Themes are now composed of colors palletes and component themes rather than just component themes, this makes it easier to reuse colors across component themes.

This is how the [Dark theme](https://github.com/marc2332/freya/blob/0db8d4d7d1c44c4cf591bbf898d973a163f97f75/crates/hooks/src/theming/themes.rs#L7) is defined now:

```rs
pub const DARK_THEME: Theme = Theme {
    name: "dark",
    colors: ColorsSheet {
        primary: cow_borrowed!("rgb(103, 80, 164)"),
        focused_primary_border: cow_borrowed!("rgb(223, 180, 255)"),
        secondary: cow_borrowed!("rgb(202, 193, 227)"),
        tertiary: cow_borrowed!("rgb(79, 61, 130)"),
        surface: cow_borrowed!("rgb(60, 60, 60)"),
        secondary_surface: cow_borrowed!("rgb(45, 45, 45)"),
        neutral_surface: cow_borrowed!("rgb(25, 25, 25)"),
        focused_surface: cow_borrowed!("rgb(15, 15, 15)"),
        opposite_surface: cow_borrowed!("rgb(125, 125, 125)"),
        secondary_opposite_surface: cow_borrowed!("rgb(150, 150, 150)"),
        tertiary_opposite_surface: cow_borrowed!("rgb(170, 170, 170)"),
        background: cow_borrowed!("rgb(20, 20, 20)"),
        focused_border: cow_borrowed!("rgb(110, 110, 110)"),
        solid: cow_borrowed!("rgb(240, 240, 240)"),
        color: cow_borrowed!("rgb(250, 250, 250)"),
        primary_color: cow_borrowed!("white"),
        placeholder_color: cow_borrowed!("rgb(210, 210, 210)"),
        highlight_color: cow_borrowed!("rgb(96, 145, 224)"),
    },
    ..BASE_THEME
};
```

### Built-in Components style
The built-in components style have been refreshed with a more modern style.

The button component now has 3 variants of 1, `Button`, `FilledButton`, and `OutlineButton`.
![Buttons variants Screenshot](/blog/0.3/buttons_variants.png)

The Scrollbar design has been refreshed, it now floats over the content with a small width unless you hover near it, then it gets bigger and gets a semi-transparent background.
![Scroll Screenshot](/blog/0.3/scroll.png)

Here there is a collection of some of the components, with a refreshed style:

![Refreshed Components Screenshot](/blog/0.3/refreshed_components.png)

### New Docs
Freya uses [docs.rs](docs.rs) more than ever, all elements, attributes and events have been documented and you can even see their docs when hovering them in your code editor.

> If you happen to see something missing or not well-explained please open an issue or even feel free to send a Pull Request.

Also, the most important (more to come in the future) built-in components offer previews embedded in docs.rs so you can see how a component looks like before even using it.

Here is a docs-only gallery section with a previews of them, you can also see the individual previews in their respective section.

![Components Gallery Screenshot](/blog/0.3/components_gallery.png)

### Dioxus 0.6
Freya now uses Dioxus 0.6, nothing important here honestly!

### New components

#### AnimatedPosition

The `AnimatedPosition` component animates its inner content position across time, any layout change that could make its content move, will then be animated. For this it needs to know the `width` and `height` in advance.

```rust
fn app() -> Element {
    rsx!(
        AnimatedPosition {
            width: "110",
            height: "60",
            function: Function::Quad,
            duration: Duration::from_millis(250),
            rect {
                background: "red",
                width: "60",
                height: "110"
            }
        }
    )
}
```

Here for example, clicking on "Toggle" changes the direction of the cards container, thus changing the cards position:

<video muted autoplay playsinline loop >
    <source src="/blog/0.3/animated_position_cards.webm" type="video/webm" >
</video>

Source code of the example in [GitHub](https://github.com/marc2332/freya/blob/main/examples/animated_position.rs).

Here is another example of cards that can be dragged and dropped:

<video muted autoplay playsinline loop >
    <source src="/blog/0.3/animated_position_drag.webm" type="video/webm" >
</video>

Source code of the example in [GitHub](https://github.com/marc2332/freya/blob/main/examples/drag_drop.rs).


#### GlobalAnimatedPosition

`GlobalAnimatedPosition` is very similar to `AnimatedPosition` but it works with any content from anywhere and anywhere. It requires an extra `id` value that is guaranted to not change across time for this given element.

Here is an example of a grid, where each element is identified by a number. It doesnt matter that the elements get shuffled because each one is identified, therefore we can know where it comes from and where it goes and thus animate the transition.

The implementation could be improved to make the animation more fluid though.

<video muted autoplay playsinline loop >
    <source src="/blog/0.3/global_animated_position_grid.webm" type="video/webm" >
</video>


Source code:
```rust
fn app() -> Element {
    let mut grid = use_signal(|| Grid::new(5));
    rsx!(
        rect {
            spacing: "12",
            main_align: "center",
            cross_align: "center",
            width: "fill",
            height: "fill",
            // This context provider is what stores the positions
            // The generic type is the ID type used for the cells
            GlobalAnimatedPositionProvider::<usize> {
                Button {
                    onpress: move |_| grid.write().suffle(),
                    label {
                        "Shuffle"
                    }
                }
                rect {
                    spacing: "6",
                    for row in grid.read().cells.chunks(5) {
                        rect {
                            direction: "horizontal",
                            spacing: "6",
                            for cell in row {
                                GlobalAnimatedPosition::<usize> {
                                    key: "{cell.id:?}",
                                    width: "100",
                                    height: "100",
                                    function: Function::Expo,
                                    duration: Duration::from_millis(600),
                                    id: cell.id,
                                    rect {
                                        width: "100",
                                        height: "100",
                                        background: "rgb({cell.id * 6}, {cell.id * 8}, { cell.id * 2 })",
                                        corner_radius: "32",
                                        color: "white",
                                        main_align: "center",
                                        cross_align: "center",
                                        label {
                                            "{cell.id:?}"
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    )
}
```

Complete source code of the example in [GitHub](https://github.com/marc2332/freya/blob/main/examples/grid_shuffle.rs).


#### SelectableText
New read-only component that allows selecting text to copy for example.


Simple example:

```rust
fn app() -> Element {
    rsx!(
        SelectableText {
            value: "You can select this looooooooooong text"
        }
    )
}
```

![Text Selectable Screenshot](/blog/0.3/selectable_text.png)

Source code of the example in [GitHub](https://github.com/marc2332/freya/blob/main/examples/selectable_text.rs).

#### OverflowedContent
Animate a long content that otherwise could not be displayed, in a small container.

Simple example:

```rust
fn app() -> Element {
    rsx!(
        Button {
            OverflowedContent {
                width: "100",
                rect {
                    direction: "horizontal",
                    cross_align: "center",
                    label {
                        "Freya is a cross-platform GUI library for Rust"
                    }
                }
            }
        }
    )
}
```

<video muted autoplay playsinline loop >
    <source src="/blog/0.3/overflowed_content.webm" type="video/webm" >
</video>

Source code of the example in [GitHub](https://github.com/marc2332/freya/blob/main/examples/animated_overflow_content.rs).


#### ResizableContainer
`ResizableContainer` in combination with `ResizablePanel` and `ResizablePanel` makes it possible to have panels whose size can be resized by dragging thin bars (also called handles).

```rust
fn app() -> Element {
    rsx!(
        ResizableContainer { // This is where ours panels and handles will be defined, default direction is vertical
            ResizablePanel { // A resizable panel with a minimum size of 50
                initial_size: 50., // Custom initial size, default is 10
                label {
                    "Hello"
                }
            }
            ResizableHandle { } // A thin bar
            ResizablePanel {
                initial_size: 50.,
                ResizableContainer { // And inside this panel we have yet another container, but this time it is horizontal
                    direction: "horizontal",
                    ResizablePanel {
                        initial_size: 35.,
                        label {
                            "World"
                        }
                    }
                    ResizableHandle { }
                    ResizablePanel {
                        initial_size: 20.,
                        min_size: 20., // Custom minimum size, default is 4
                        label {
                            "!"
                        }
                    }
                }
            }
        }
    )
}
```


<video muted autoplay playsinline loop >
    <source src="/blog/0.3/resizable_container.webm" type="video/webm" >
</video>

Source code of the example in [GitHub](https://github.com/marc2332/freya/blob/main/examples/resizable_container.rs).

#### Tooltip
`Tooltip` is now an standalone component you can use to show some text when a given content is hovered:

```rs
fn app() -> Element {
    rsx!(
        TooltipContainer {
            tooltip: rsx!(
                Tooltip {
                    text: "You can see me now!"
                }
            ),
            Button {
                label { "Hover me" }
            }
        }
    )
}
```

![Tooltip Screenshot](/blog/0.3/tooltip.png)

Source code of the example in [GitHub](https://github.com/marc2332/freya/blob/main/examples/tooltip.rs).

#### AnimatedRouter

This simplifies animating transitions between pages of a router.

<video muted autoplay playsinline loop >
    <source src="/blog/0.3/animated_router.webm" type="video/webm" >
</video>

Source code of the example in [GitHub](https://github.com/marc2332/freya/blob/main/examples/animated_tabs.rs).


### Animations API
The `use_animation` hook now offers fully typed animations, making it easier to use it. Before, the animated values were type-erased and so their capabilities were limited.

```rust
fn app() -> Element {
    // UseAnimation<AnimNum>
    let animation = use_animation(|conf| {
        conf.auto_start(true);
        AnimNum::new(0., 360.)
        .time(500)
        .ease(Ease::InOut)
        .function(Function::Expo)
    });
    // ReadOnly<AnimNum>, you can pass it to other components if you need
    let sequential = animation.get();

    // &AnimNum
    let anim_num = &*sequential.read();

    // f32
    let rotation: f32 = anim_num.into();

    rsx!(
        rect {
            width: "100",
            height: "100",
            rotate: "{rotation}deg",
            background: "rgb(0, 119, 182)"
        }
    )
}
```

An example of this is the new `SequentialAnimation`, an animated value that can animate `N` amount of values:

```rust
fn app() -> Element {
    let animations = use_animation(|conf| {
        conf.auto_start(true);
        AnimSequential::new([
            AnimNum::new(0., 360.)
                .time(500)
                .ease(Ease::InOut)
                .function(Function::Expo),
            AnimNum::new(0., 180.)
                .time(2000)
                .ease(Ease::Out)
                .function(Function::Elastic),
        ])
    });

    let sequential = animations.get();

    let rotate_a = sequential.read()[0].read();
    let rotate_b = sequential.read()[1].read();

    rsx!(
        rect {
            width: "100",
            height: "100",
            rotate: "{rotate_a}deg",
            background: "rgb(0, 119, 182)"
        },
        rect {
            width: "100",
            height: "100",
            rotate: "{rotate_b}deg",
            background: "rgb(0, 119, 182)"
        }
    )
}
```

<video muted autoplay playsinline loop >
    <source src="/blog/0.3/sequential_animation.webm" type="video/webm" >
</video>

Source code of the example in [GitHub](https://github.com/marc2332/freya/blob/main/examples/sequential_animation.rs).


### Devtools
- Persisted routing
- Better layout preview

### Accessibility
- Keyboard navigation improved
- UI improved when focused
- Better use_focus hook

![Tooltip Screenshot](/blog/0.3/accessibility_ime.png)

### `freya-testing`
`freya-testing`, aka the headless testing runner to test freya components, now supports making snapshots of the UI canvas and saving them to the disk.

This can be very useful for when you want to debug something visually in a test.

```rust
fn app() -> Element {
    let mut count = use_signal(|| 0);

    rsx!(
        rect {
            onclick: move |_| count += 1,
            label {
                font_size: "100",
                font_weight: "bold",
                "{count}"
            }
        }
    )
}

#[tokio::main]
async fn main() {
    let mut utils = launch_test(app);

    // Initial render
    utils.wait_for_update().await;
    utils.save_snapshot("./snapshot_before.png");

    // Emit click event
    utils.click_cursor((100., 100.)).await;

    // Render after click
    utils.save_snapshot("./snapshot_after.png");
}
```

As a matter of fact, I reused this same API to create the embedded previews in docs.rs.

### New Examples
Here is a list of just a few new cool examples I added since the last release.

[Animated VirtualScrollview](https://github.com/marc2332/freya/blob/main/examples/animated_virtual_scroll_view.rs):

<video muted autoplay playsinline loop >
    <source src="/blog/0.3/animated_virtual_scrollview.webm" type="video/webm" >
</video>

[mvandevander](https://github.com/marc2332/freya/blob/main/examples/mvandevander.rs)

![mvandevander Screenshot](/blog/0.3/mvandevander.png)

### From now on

I think I will probably stop making these blog posts as they take me too much time to write, I want to move to a faster release schedule so I will instead focus on simply make better changelogs in the GitHub releases. If something is worth of a blog post I will do it tho!

Marc :)