---
title: 'Freya 0.2'
date: 2024-04-14
description: '0.2 release of Freya.'
author: 'marc2332'
layout: ../../layouts/BlogPostLayout.astro
slug: "0.2"
---

## üëã hey 

Hey! I am [Marc](https://github.com/marc2332/), I just released the v0.2 of Freya, a native cross-platform GUI library for Rust ü¶Ä.

<video muted autoplay playsinline loop >
    <source src="/demo.mp4" type="video/mp4" >
</video>

## üß¨ Dioxus 0.5 

Dioxus, the UI library in which Freya is built on, has recently released a new version `0.5`, adding a bunch of new features. If I had to describe their new release with one word, it would be **Simplicity**.

Here are the main changes of their release:
- Removal of `Scope` parameter in all Components
- Removal of the `render!()` macro
- Simplification all the state management by using Signals
- Removal of lifetimes in Props, `Eventhandler`s and `Element`s

## üß∞ Components 

Quite a few new components have been added to `freya-components`, existing have been improved as well.

Here are the new ones.

### ü™ü Table 

We all know what a table is, and this is no different.

You basically compose the table with the different available components. This allows you to sort the data in whatever way you want. You can see a more complex example [here](https://github.com/marc2332/freya/blob/main/examples/table.rs).


Example:

```rust
// Actual data that might coming from anywhere, in this case it's generated for the sake of the example
let data = use_signal(|| {
    (0..10)
        .map(|i| {
            vec![
                format!("{i}"),
                format!("{}", 5 - i + 30),
                format!("{}", 10 - i + 70),
            ]
        })
        .collect::<Vec<Vec<String>>>()
});

let columns = use_signal(|| {
    vec![
        "ID".to_string(),
        "Age".to_string(),
        "Weight".to_string(),
    ]
});

rsx!(
    Table {
        columns: columns.len(),
        TableHead {
            TableRow {
                for (n, text) in columns.read().iter().enumerate() {
                    TableCell {
                        key: "{n}",
                        label {
                            "{text}"
                        }
                    }
                }
            }
        }
        TableBody {
            // You could even use VirtualScrollView if you had to deal with large data sets
            ScrollView {
                for (i, items) in data.read().iter().enumerate() {
                    TableRow {
                        key: "{i}",
                        alternate_colors: i % 2 == 0,
                        for (n, item) in items.iter().enumerate() {
                            TableCell {
                                key: "{n}",
                                label {
                                    width: "100%",
                                    text_align: "right",
                                    "{item}"
                                }
                            }
                        }
                    }
                }
            }
        }
    }
)
```

![image](/blog/0.2/table.png)

### üßç‚Äç‚ôÇÔ∏è Body 

`Body` is a new simple container that comes with styled background matching the current theme and expands to the available area. 
Not very innovating as you can see, but quite useful for pretty much all apps that want to use themes.

Example:

```rust
use_init_theme(DARK_THEME);

rsx!(
    Body {
        Button {
            label {
                "Hello, World!"
            }
        }
    }
)
```

![image](/blog/0.2/body.png)

### üîÉ ProgressBar 

A simple progress bar to display the current progress of something. You only need to feed it a `f32`.

Example:

```rust
let progress = 67.0; // Could be derived from another state for example

rsx!(
    ProgressBar {
        show_progress: true,
        progress
    }
)
```

![image](/blog/0.2/progress_bar.png)

### üíª VirtualScrollView 

`VirtualScrollView` the component used to create virtualized scroll views has been simplified and improved.

- You don't need to wrap the builder function inside a `Box<T>` anymore
- Reduced the builder function arguments from 4 to 2
- Optional partial caching of elements

Example:

```rust
let values = use_signal(|| ["Hello, World!"].repeat(300));

rsx!(VirtualScrollView {
    length: values.read().len(),
    item_size: 25.0,
    direction: "vertical",
    cache_elements: false, // Default is true.
    builder: move |index, _: &Option<()>| {
        let value = values.read()[index];
        let background = if index % 2 == 0 {
            "rgb(200, 200, 200)"
        } else {
            "white"
        };
        rsx! {
            rect {
                key: "{index}",
                background: "{background}",
                width: "100%",
                label {
                    height: "25",
                    "{index} {value}"
                }
            }
        }
    }
})
```

### üç´ Snackbar 

A new `Snackbar` component has been added to let you render whatever you want, e.g information, in a small animated box that will pop up from the bottom.

Example:

```rust
let mut show = use_signal(|| false);

rsx!(
    Button {
        onclick: move |_| {
            show.toggle();
        },
        label { "Toggle" }
    }
    SnackBar {
        show,
        label {
            "Hello, World!"
        }
    }
)
```

See [X (Twitter) üé•](https://x.com/mkenzo_8/status/1757766554102415496)

### üß± Sidebar 

`Sidebar` is a new component to let you have have a menu in the left side and content in the right side, this is specially useful when used in combination with `dioxus-router`. It also supports navigating with the mouse back and forward buttons.

![image](/blog/0.2/sidebar.png)

### üìª Radio 

Use the new `Radio` component to select a value from a list. It does not have any hidden inner state, you must handle the state logic yourself, which might need a little boilerplate at first but it simplifies things at scale.

Example (only one radio to simplify things):

```rust
let mut selected = use_signal(|| Choice::FirstChoice);

rsx!(
    Tile {
        onselect: move |_| selected.set(Choice::FirstChoice),
        leading: rsx!(
            Radio {
                selected: *selected.read() == Choice::FirstChoice,
            },
        ),
        label { "First choice" }
    }
)
```

![image](/blog/0.2/radio.png)

### ‚úÖ Checkbox 

Toggle different options from a list of values with `Checkbox`. Just like [`Radio`], Checkbox doesn't have any inner hidden state, you must write the state logic yourself.

Example (only one checkbox to simplify things):

```rust
let mut selected = use_signal::<HashSet<Choice>>(HashSet::default);

rsx!(
    Tile {
        onselect: move |_| {
            if selected.read().contains(&Choice::FirstChoice) {
                selected.write().remove(&Choice::FirstChoice);
            } else {
                selected.write().insert(Choice::FirstChoice);
            }
        },
        leading: rsx!(
            Checkbox {
                selected: selected.read().contains(&Choice::FirstChoice),
            },
        ),
        label { "First choice" }
    }
)
```

![image](/blog/0.2/checkbox.png)

### üì∞ Popup 

`Popup` , also called `Dialog` or `Floating Window` in other frameworks / libraries is exactly what you think it is, a floating container that is in top of anything else (hence why it's called popup, because it pops out!). 
It comes with a close button on the top right corner and you can put anything you want inside of it.

![image](/blog/0.2/popup.png)

### üñ±Ô∏è Menu 

With the new `Menu` component you can compose floating menus with the help of `MenuButton` and `SubMenu`.

Example:

```rust
let mut show_menu = use_signal(|| false);

rsx!(
    Button {
        onclick: move |_| show_menu.toggle(),
        label { "Open Menu" }
    },
    if *show_menu.read() {
        Menu {
            onclose: move |_| show_menu.set(false),
            MenuButton {
                label {
                    "Button 1"
                }
            }
            SubMenu {
                menu: rsx!(
                    MenuButton {
                        label {
                            "Button 1"
                        }
                    }
                ),
                label {
                    "More"
                }
            }
        }
    }
)
```

![image](/blog/0.2/menu.png)

### üó∫Ô∏è ActivableRoute and `use_activable_route` 

There might a case where you want to know whether a route is selected or not, in order to show a part of the UI different, like a button with a different color for instance. This used to require you to know what type of Route you were using in your app in the components where you wanted to display different based on what route was selected.

`ActivableRoute` and `use_activable_route` fixes this by passing a context to all the children of their, this way they don't need to know if a certain route is enabled or not, they simply know whether **some** route is enabled.

```rust
Link { 
    to: Route::Home, // Direction route
    ActivableRoute {
        route: Route::Home, // Activation route
        SidebarItem { 
            // `SidebarItem` will now appear "activated" because
            // `ActivableRoute` is letting it know whether `Route::Home` is enabled 
            // or not, without the need to add router-specific logic in `SidebarItem`.
            label {
                "Go to Hey ! üëã"
            }
        },
    }
},
```

## ü™ù Hooks 

All built-in hooks are now `Copy` thanks to the new Signals system in Dioxus, which means you won't need to use `to_owned![]` as often as before.

### ‚ôªÔ∏è `use_asset_cacher`

This new hooks provides a global store for assets to be stored and used across components in your app, it's actually powering `NetworkImage` now.

It simply let's you cache an asset in the form of bytes with a given duration. Once the duration has elapsed from the moment you used the last time, it will get removed from the cache.


### üé• `use_animation` 

Previously, there used to be two hooks for animations `use_animation` and `use_animation_transition`, these two have now been merged under `use_animation` and refactored from the gound up, the api is now more flexible and robust than before.

See this cool example on [X (Twitter) üé•](https://x.com/mkenzo_8/status/1756697617348579731)

For instance, let's say you want to create an animation that will animate from a value from `25.0` to `75.0` in a duration of `200ms` with an `Expo` function and an `Out` ease.

```rust
// Create animation
let animation = use_animation(|ctx| {
    ctx.with(
        AnimNum::new(25.0, 75.0)
            .time(200) // Alternative to `.duration(Duration::from_millis(200))` 
            .function(Function::Expo)
            .ease(Ease::Out),
    )
});

// Retrieve current value
let value = animation.get().as_f32();

// UI
rsx!(
    Button {
        onclick: move |_| animation.start(), // Start the animation on click
        label {
            "Value {value}"
        }
    }
)
```

You could also have multiple animations, that start automatically and reverse when they are finished:

```rust
// Create animation
let animation = use_animation(|ctx| {
    ctx.auto_start(true); // Start the animation when this component is mounted
    ctx.on_finish(OnFinish::Reverse); // When the animation finishes, run it in reverse of the last run
    (
        ctx.with(AnimNum::new(0., 100.).time(200)), // Animate a value from 0 to 100 in 200ms
        ctx.with(AnimColor::new("rgb(245, 25, 30)", "blue").time(200)) // Animate a color transition in 200ms
    )
});

// Retrieve values
let (width, color) = animation.get();
let width = width.read().as_f32();
let background = color.read().as_string();

// UI
rsx!(
    rect {
        height: "100%",
        width: "{width}",
        background: "{background}"
    }
)
```

## üèóÔ∏è Layout 

### üìê Alignments 
Previously, Freya had a very basic way of aligning elements by using `display: center` and `direction: both`, this wasn't easy to understand neither to use. So, I have deprecated the `display` attribute and the `both` mode of the `direction` attribute.

Now, `direction` now only accepts `vertical` and `horizontal` and to configure the alignment of both axis you can use the `main_align` and `cross_align` attributes with both accepting the values of `start | center | end`.

`main_align` aligns the elements in the selected direction and `cross_align` in the opposite.

Example vertically:
```rust
rsx!(
    rect {
        height: "100%",
        width: "100%",
        direction: "vertical",
        main_align: "center", // All elements will be centered vertically because `direction` is vertical
        cross_align: "end", // All elements will be aligned horizontally in the end 
        rect {
            width: "100",
            height: "100",
            background: "red",
        }
        rect {
            width: "100",
            height: "100",
            background: "yellow",
        }
    }
)
```

![image](/blog/0.2/alignment_1.png)

Example horizontally:
```rust
rsx!(
    rect {
        height: "100%",
        width: "100%",
        direction: "horizontal",
        main_align: "center", // All elements will be centered horizontally because `horizontal` is vertical
        cross_align: "start", // All elements will be aligned vertically in the center
        rect {
            width: "100",
            height: "100",
            background: "red",
        }
        rect {
            width: "100",
            height: "100",
            background: "yellow",
        }
    }
)
```

![image](/blog/0.2/alignment_2.png)

### üìå Position absolute 
Freya now supports absolute positioning which means that you can make a certain element float relatively to it's parent.

```rust
rsx!(
    rect {
        background: "blue",
        width: "100%",
        height: "100%",
    }
    rect {
        background: "yellow",
        position: "absolute",
        position_top: "10",
        position_left: "10",
        width: "50",
        height: "50",
        corner_radius: "100"
    }
)
```

![image](/blog/0.2/alignment_3.png)

### üí™ `content: fit` and `fill-min`

The new `content` attribute bring more layout flexibility by letting you expand the size of certain elements to the max of the biggest element.

Example:

```rust
rsx!(
    rect {
        content: "fit",
        height: "100%",
        rect {
            width: "fill-min", // Use the width of the biggest sibling element (300)
            height: "25%",
            background: "rgb(71, 147, 175)",
        }
        rect {
            width: "150", // Fixed size of 150
            height: "25%",
            background: "rgb(255, 196, 112)",
        }
        rect {
            width: "fill-min", // Use the width of the biggest sibling element (300)
            height: "25%",
            background: "rgb(221, 87, 70)",
        }
        rect {
            width: "300", // Fixed size of 300
            height: "25%",
            background: "rgb(139, 50, 44)",
        }
    }
)
```

![image](/blog/0.2/content_fit.png)

### ü•§ `fill` size 

Size attributes like `width` and `height` now accept `fill` as attribute, this will make the element use the remaining available area.

```rust
rsx!(
    rect {
        height: "50%",
        width: "100%",
        background: "rgb(0, 119, 182)",
    }
    rect {
        height: "fill",
        width: "100%",
        background: "rgb(20, 150, 220)",
    }
)
```

![image](/blog/0.2/fill_size.png)


### ‚ö° Performance improvements 
I have made some significant optimizations around the layout so it's faster, special alignments will now run faster than before. Incremental measuring should be faster and more precise as well.


## üñåÔ∏è Theming 
The theming system has been remade to be more flexible and scalable. Now you can pass override specific parts or the whole theme of a specific component with a simple prop.

Thanks to [Leonard (@tigerros)](https://github.com/tigerros) !

Example:

```rust
rsx!(
    Button {
        theme: theme_with!(ButtonTheme {
            padding: "0".into(), // Passing custom padding before was possible
            hover_background: "black".into() // But passing custom hover wasn't possible
        }),
        label {
            "Hello, World!"
        }
    }
)
```


## üìö Docs 
The docs have been reorganized and most API references previously located in the Book have now been integrated into the source code itself allowing these to be versioned. 

The book is now also smaller and will serve as a place for guides and similar.

Some new [examples](https://github.com/marc2332/freya/tree/main/examples) have been added, some removed and others updated!

## üìû Events 
### ü´ß Event Bubbling 
Due to a bug in Dioxus (now fixed), Freya was not capable of having proper [Event Bubbling](https://en.wikipedia.org/wiki/Event_bubbling).

This was very limiting for certain components, specially those that float over others. 

Fortunately this is no longer the case and Freya now properly supports event bubbling, which means that you can let the events propagate from bottom to top elements and stop them when you wish to.

Example:

```rust
rsx!(
    rect {
        onclick: |_| {
            println!("Clicked B!");
        },
        rect {
            onclick: |e| {
                // Stop the bubbling of the event if you want to
                e.stop_propagation();
                println!("Clicked A!");
            },
            background: "blue",
            label {
                "hey"
            }
        }
    }
)
```

### ü§ô New Events 
A few new events have been added and changed.

`onclick` now only triggers when clicking with the lef button of the mouse, and there is now `onmiddleclick` and `onrightclick` for the other two.


New events for file drag and drop have been added, `onfiledrop`, `onglobalfileover` and `onglobalfileovercancelled`.

## üî® Core 

### üî≠ Viewports and Layer 

Freya used to organize all the Nodes by layers and calculate their viewports in every single frame, while this was fast enough most of the time, an extra performance improvement is always welcome. 

Now, these are incrementally created and removed in parallel, thus being so much faster.

### üìÑ Text shaping caching 
Shaping of text is now cached between rerenders unless they need to be redone, obviously.


## üöö Platform integrations 
- Support for specifying the Window icon, max  width and height, and added a window builder hook
- Read window size with use_platform

## üë®‚Äçü¶Ø Headless Testing runner 
Smarter polling of the VirtualDOM, making it easier to use, and minor improvements (resize method, etc)

Notable additions:

- `is_visible`: Assert whether a specific Node is visible in the screen or not.
- `get_by_text` Get a specific Node searching by its containing text.


## ü¶æ Accessibility 
Partial IME support has been added, but there is still work to do regarding text editing.

Some of the built-in components have been made more accessibile as well, but not all of them. Again, there is work to do.

## ‚å®Ô∏è Text Editing 
- Fixed small bugs and made the experience just better
- Added support for **Copy**, **Cut**, **Paste**, **Redo** and **Undo** thanks to the new `use_clipboard` hook added to [Dioxus SDK](https://github.com/dioxusLabs/sdk)

## üåê Updated the Website 
The website has been updated revamped, a few people have told me that the landing doesn't work because when you click on the clickable element it doesn't update the counter, but it's not supposed to work at all, it was just a UI demo of how the app would look.
Anyway, I revamped it and it now has video instead. Also, the website now ships a total of `0kb` of JavaScript to client browsers. 

And a blog has been integrated as well as you can tell.

## üç¥ Forked native-core and native-core-macro 
[native-core](https://crates.io/crates/dioxus-native-core) and [native-core-macro](https://crates.io/crates/dioxus-native-core-macro) crates were use by the native renderers of Dioxus, and also Freya. But they have now been deprecated, so I forked them and took the opportunity to make some changes such as removing unused features by Freya or adapted certain APIs to fit better into Freya:

- Remove event listeners from TextNodes
- Typed Enums for tag, attributes and listeners in DOM Nodes instead of `String`s
- Remove Namespaces
- Remove Custom Elements
- Not store TextNodes states in the ECS
- Simplified DOM Traversal
- Simplified and removed other things not used by Freya

## üëç Other 
- Reduce deps from around 500 to 417 (windows)
- new cargo-packager example
Removed old and ugly examples, updated some and added new!

## ü´Ç Community 
While I work in Freya most of the time, I also maintain other crates, some freya-compatible, such as [`dioxus-radio`](https://github.com/dioxus-community/dioxus-radio) or [Dioxus SDK](https://github.com/DioxusLabs/sdk). These two and others have been updated to Dioxus 0.5, which means they can be used in Freya 0.2.

I have plans on adding support for Freya in [`dioxus-free-icons`](https://github.com/dioxus-community/dioxus-free-icons/), so freya users gain access ot thousands of icons. Help is [appreciated](https://github.com/dioxus-community/dioxus-free-icons/issues/39), feel free to contribute! 

## üõ§Ô∏è Roadmap 

### More built-in components
I think that GUI frameworks should have decent support for the most popular and basic components, so the devs can get started quickly.

### More accessible components
Some components are have some level of accessibility support but others don't, and the accessibility integration in general could be polished.

### Better testing tools
Some people think testing UI is useless, and they are probably right, except for libraries or critical apps in my opinion.

I want to be sure all my components are working when I make a change in the core of my project. Testing a button might sound stupid but when you have a virtual scroll view, things can get complicated really quick, better test it just to be sure.

### Improved Docs
While I try to doc everything I can the best way possible, there is so many things and I am not perfect. I'll try to improve this area, help is appreciated too!

### Vulkan Support

Freya currently runs on OpenGL, I want to experiement with running it with vulkan (and perhaps leave OpenGL as a runtime fallback?). Skia supports doing so, but I lack the knowledge for this. So, if you know about this stuff feel free to contribute (I'd love you to!), more [info](https://github.com/marc2332/freya/issues/552).

# üôã‚Äç‚ôÇÔ∏èSpecial thanks! 
Thanks for the Dioxus core [team](https://github.com/orgs/DioxusLabs/people) for all the hard work on improving the framework, and also to the friendly and helpful Dioxus Community :smile: üß¨

Also thanks to my Github [Sponsors](https://github.com/sponsors/marc2332) for for their montly sponsoring!

If you are interested in supporting financially, more sponsors are welcome :slightly_smiling_face: :thumbsup: 
